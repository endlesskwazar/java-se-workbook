# Базовий синтаксис класу

## Класи в java не підтримують перевизначення операторів

# Методи класу Object

## toString()

**toString ()** надає рядкове представлення об'єкта і використовується для перетворення об'єкта в String. Метод toString () для класу Object повертає рядок, що складається з імені класу, об'єктом якого є екземпляр, символу `@ ' та шістнадцяткового відображення хеш-коду об'єкта. Іншими словами, він визначається як:

```java
public String toString()
{
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

Завжди рекомендується перевизначити метод toString(), щоб отримати власне рядкове - представлення об'єкта.

Наприклад, використовуючи атрибути класу:

```java

```

## hashCode()

Для кожного об'єкта JVM генерує унікальне число, яке називається хеш-кодом. Він повертає окремі цілі числа для різних об'єктів. Поширене помилкове уявлення про цей метод полягає в тому, що метод **hashCode ()** повертає адресу об'єкта, що є невірним. Він перетворює внутрішню адресу об'єкта в ціле число за допомогою алгоритму. Метод **hashCode ()** є нативні, тому що в Java неможливо знайти адресу об'єкта, тому він використовує рідні мови, такі як C/C ++, щоб знайти адресу об'єкта.

Використання методу **hashCode ()**: Повертає хеш-значення, яке використовується для пошуку об’єкта в колекції. JVM (Java Virtual Machine) використовує метод хеш-коду під час збереження об'єктів у хешованих структурах даних, таких як HashSet, HashMap, Hashtable тощо. Основна перевага збереження об'єктів на основі хеш-коду полягає в тому, що пошук стає простим.

> Примітка: Перевизначення методу hashCode () потрібно зробити таким чином, що для кожного об'єкта ми генеруємо унікальне число. Наприклад, для класу "Студент" ми можемо повернути номер залікової книги, оскільки він унікальний.

Приклад:

```java

```

## equals(Object obj)

Порівняє переданий об’єкт із "this" об'єктом (об'єктом, щодо якого викликається метод). Це дає загальний спосіб порівняння об'єктів на рівність. Для отримання власної умови рівності потрібно перевизначити метод **equals (Object obj)**.

Стандартна реалізація:

```java

```

Приелад перевизначення **equals()**:

```java

```

## getClass()

???????????????

## finalize()

Цей метод викликається безпосередньо перед тим, як об’єкт буде знищенно. Колектор сміття викликає його на об'єкті, коли збирач сміття визначає, що більше немає посилань на об'єкт.

?????????????????????????????????

# Скільки пам'яті займають об'єкти

# Пакети

# Три принципи ООП

## Інкапсуляція

## Наслідування

### Наслідування - зло?

## Поліморфізм

### Replace conditional with polymorphism

Такі конструкції як if,switch є елементами структурного програмування. Якщо ці конструкції зустрічаються у Вашому коді і створені для того, щоб виконувати рогалудження в залежності від типу об'єкта або його атрибуватів можна застосувати такий прийом як "Replace switch with polymorphism".

Розгляньмо наступний код:

```java
class SalesPerson {
	
	private String name;
	private int skill;
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getSkill() {
		return skill;
	}

	public void setSkill(int skill) {
		this.skill = skill;
	}

	public SalesPerson(String name, int skill) {
		this.name = name;
		this.skill = skill;
	}
	
	public String getSkillTitle () {
		if (skill >=0 && skill <=5)
			return "Junior";
		else
			if (skill > 5 && skill <= 10)
				return "Middle";
		return "Sineor";
	}
}
```

Метод getSkillTitle в залежності від цілочисельного параметра skill повертає його рядкове представлення. Давайте змінимо наш код використовуючи "Replace conditional with polymorphism". Для цього:

- Створемо підкласи, яким відповідають відповідні гілки розгалудження.
- У підкласах створемо загальний метод і перенесіть відповідний код гілки із оригінального коду
- Замінемо умовний оператор викликом загального методу

```java

```

# Порядок ініціалізації класів

# Абстрактні класи

# Інтерфейси

# Enum

# Бонус. Jigsaw - модулі 

# Домашня робота

# Контрольні запитання